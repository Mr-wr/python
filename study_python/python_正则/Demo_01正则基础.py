#!/usr/bin/env python3
#告诉linux system this is  execute  procedure
#windows 会忽略这个
# -*- coding: utf-8 -*-
#告诉python解析器是按照utf-8编码的
import re
#--------------------正则表达式
#1、用\d可以匹配一个数字，\w可以匹配一个字母或数字
#2、.可以匹配任意字符
#3、*表示任意多个，+表示至少一个、{n}表示任意n个字符、{n-m}表示n-m个字符
#例如：\d{3-5}：12345
#4、\s可以匹配一个空格（tab也算）、\s+表示至少一个空格
#因为-是特殊字符所以要用\转义
#例如：'123-564489':\d{3}\-\d{3-8}
#--------------------------进阶二级斗者
#[a-zA-Z\_][0-9a-zA-Z\_]*可以匹配由字母或下划线开头，
# 后接任意个由一个数字、字母或者下划线组成的字符串，也就是Python合法的变量
#|或者、^行开头，^\d必须以数字开头、$表示行的结束、
#--------------------------开始实战
#re.match目前只学了两参数第一个是要匹配的正则表达式，第二个是要匹配的字符串
#如果匹配成功的话返回一个math对象，不成的话返回none
s = '123-87984'
r = r'^\d{3}\-\d{3,8}$'
print(re.match(r,s))#><re.Match object; span=(0, 9), match='123-87984'>
#--------------------------------------切分字符串

re.split(r'\s+', 'a b   c')#['a', 'b', 'c']
re.split(r'[\s\,]+', 'a,b, c  d')#['a', 'b', 'c', 'd']
re.split(r'[\s\,\;]+', 'a,b;; c  d')#['a', 'b', 'c', 'd']

#-------------------------------分组
#^(\d{3})-(\d{3-8})$
m = re.match(r'^(\d{3})-(\d{3,8})$', '010-12345')
#0索引的永远是原字符串
m.group(0)#'010-12345'
m.group(1)#'010'
m.group(2)#'12345'
#--------------------------------贪婪匹配
#正则默认的就是贪婪匹配
#加上？就是可以让他采用非贪婪匹配
re.match(r'^(\d+?)(0*)$', '102300').groups()#('1023','00')
#----------------------------------编译
#如果一个正则表达式要用多次的话可以先预编译该正则表达式
#例如：
re_phon = re.compile(r'^(\d{3})-(\d{3-8})$')
re_phon.match('').group()
#练习
r'^(\w+?)(.com)$'
re_mail = re.compile(r'')














